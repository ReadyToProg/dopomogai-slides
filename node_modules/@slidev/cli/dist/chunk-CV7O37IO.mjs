import {
  ViteSlidevPlugin,
  checkEngine,
  mergeViteConfigs,
  require_semver,
  version
} from "./chunk-U44GKKNH.mjs";
import {
  createResolver,
  getRoots,
  resolveEntry
} from "./chunk-7HOZGSL4.mjs";
import {
  __toESM
} from "./chunk-BXO7ZPPU.mjs";

// node/server.ts
import { join } from "node:path";
import process from "node:process";
import { createServer as createViteServer, mergeConfig } from "vite";
async function createServer(options, viteConfig = {}, serverOptions = {}) {
  process.env.EDITOR = process.env.EDITOR || "code";
  const config = await mergeViteConfigs(
    options,
    viteConfig,
    {
      root: options.userRoot,
      optimizeDeps: {
        entries: [
          join(options.clientRoot, "main.ts")
        ]
      }
    },
    "serve"
  );
  const server = await createViteServer(
    mergeConfig(
      config,
      {
        plugins: [
          await ViteSlidevPlugin(options, config.slidev || {}, serverOptions)
        ],
        define: {
          // Fixes Vue production mode breaking PDF Export #1245
          __VUE_PROD_DEVTOOLS__: JSON.stringify(true)
        }
      }
    )
  );
  return server;
}

// node/parser.ts
import * as parser from "@slidev/parser/fs";

// node/themes.ts
var import_semver = __toESM(require_semver());
import { join as join2 } from "node:path";
import fs from "fs-extra";
var officialThemes = {
  "none": "",
  "default": "@slidev/theme-default",
  "seriph": "@slidev/theme-seriph",
  "apple-basic": "@slidev/theme-apple-basic",
  "shibainu": "@slidev/theme-shibainu",
  "bricks": "@slidev/theme-bricks"
};
var resolveTheme = createResolver("theme", officialThemes);
async function getThemeMeta(name, root) {
  const path = join2(root, "package.json");
  if (!fs.existsSync(path))
    return {};
  const { slidev = {}, engines = {} } = await fs.readJSON(path);
  if (engines.slidev && !(0, import_semver.satisfies)(version, engines.slidev, { includePrerelease: true }))
    throw new Error(`[slidev] theme "${name}" requires Slidev version range "${engines.slidev}" but found "${version}"`);
  return slidev;
}

// node/addons.ts
import { resolve } from "node:path";
import fs2 from "fs-extra";
async function resolveAddons(addonsInConfig) {
  const { userRoot, userPkgJson } = await getRoots();
  const resolved = [];
  const resolveAddonNameAndRoot = createResolver("addon", {});
  async function resolveAddon(name, parent) {
    const [, pkgRoot] = await resolveAddonNameAndRoot(name, parent);
    if (!pkgRoot)
      return;
    resolved.push(pkgRoot);
    const { slidev, engines } = await fs2.readJSON(resolve(pkgRoot, "package.json"));
    checkEngine(name, engines);
    if (Array.isArray(slidev?.addons))
      await Promise.all(slidev.addons.map((addon) => resolveAddon(addon, pkgRoot)));
  }
  if (Array.isArray(addonsInConfig))
    await Promise.all(addonsInConfig.map((addon) => resolveAddon(addon, userRoot)));
  if (Array.isArray(userPkgJson.slidev?.addons))
    await Promise.all(userPkgJson.slidev.addons.map((addon) => resolveAddon(addon, userRoot)));
  return resolved;
}

// node/options.ts
import { uniq } from "@antfu/utils";
import _debug from "debug";
var debug = _debug("slidev:options");
async function resolveOptions(options, mode) {
  const rootsInfo = await getRoots();
  const entry = await resolveEntry(options.entry || "slides.md", rootsInfo);
  const loaded = await parser.load(rootsInfo.userRoot, entry);
  const themeRaw = options.theme || loaded.headmatter.theme || "default";
  const [theme, themeRoot] = await resolveTheme(themeRaw, entry);
  const themeRoots = themeRoot ? [themeRoot] : [];
  const themeMeta = themeRoot ? await getThemeMeta(theme, themeRoot) : void 0;
  const config = parser.resolveConfig(loaded.headmatter, themeMeta, options.entry);
  const addonRoots = await resolveAddons(config.addons);
  const roots = uniq([...themeRoots, ...addonRoots, rootsInfo.userRoot]);
  debug({
    ...rootsInfo,
    ...options,
    config,
    mode,
    entry,
    themeRaw,
    theme,
    themeRoots,
    addonRoots,
    roots
  });
  return {
    ...rootsInfo,
    ...options,
    data: {
      ...loaded,
      config,
      themeMeta
    },
    mode,
    entry,
    themeRaw,
    theme,
    themeRoots,
    addonRoots,
    roots
  };
}

export {
  createServer,
  parser,
  resolveTheme,
  getThemeMeta,
  resolveAddons,
  resolveOptions
};
